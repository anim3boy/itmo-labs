## Цель работы
На простом примере разобраться с основными концепциями ООП и научиться использовать их в программах.
## Текст задания
На основе базового класса Pokemon написать свои классы для заданных видов покемонов. Каждый вид покемона должен иметь один или два типа и стандартные базовые характеристики:

* очки здоровья (HP)
* атака (attack)
* защита (defense)
* специальная атака (special attack)
* специальная защита (special defense)
* скорость (speed)

Классы покемонов должны наследоваться в соответствии с цепочкой эволюции покемонов. На основе базовых классов `PhysicalMove`, `SpecialMove` и `StatusMove` реализовать свои классы для заданных видов атак.

Атака должна иметь стандартные тип, силу (power) и точность (accuracy). Должны быть реализованы стандартные эффекты атаки. Назначить каждому виду покемонов атаки в соответствии с вариантом. Уровень покемона выбирается минимально необходимым для всех реализованных атак.

Используя класс симуляции боя `Battle`, создать 2 команды покемонов (каждый покемон должен иметь имя) и запустить бой.

## Ход работы
1. Ознакомиться с документацией, обращая особое внимание на классы `Pokemon` и `Move`. При дальнейшем выполнении лабораторной работы читать документацию еще несколько раз.
2. Скачать файл Pokemon.jar. Его необходимо будет использовать как для компиляции, так и для запуска программы. Распаковывать его не надо! Нужно научиться подключать внешние jar-файлы к своей программе.
3. Написать минимально работающую программу и посмотреть как она работает.
```
Battle b = new Battle();
Pokemon p1 = new Pokemon("Чужой", 1);
Pokemon p2 = new Pokemon("Хищник", 1);
b.addAlly(p1);
b.addFoe(p2);
b.go();
```
4. Создать один из классов покемонов для своего варианта. Класс должен наследоваться от базового класса Pokemon. В конструкторе нужно будет задать типы покемона и его базовые характеристики. После этого попробуйте добавить покемона в сражение.
5. Создать один из классов атак для своего варианта (лучше всего начать с физической или специальной атаки). Класс должен наследоваться от класса `PhysicalMove` или `SpecialMove`. В конструкторе нужно будет задать тип атаки, ее силу и точность. После этого добавить атаку покемону и проверить ее действие в сражении. Не забудьте переопределить метод describe, чтобы выводилось нужное сообщение.
6. Если действие атаки отличается от стандартного, например, покемон не промахивается, либо атакующий покемон также получает повреждение, то в классе атаки нужно дополнительно переопределить соответствующие методы (см. документацию). При реализации атак, которые меняют статус покемона (наследники `StatusMove`), скорее всего придется разобраться с классом `Effect`. Он позволяет на один или несколько ходов изменить состояние покемона или модификатор его базовых характеристик.
7. Доделать все необходимые атаки и всех покемонов, распределить покемонов по командам, запустить сражение.

## Приложение


### Мои покемоны `[имя_покемона (аттаки)]`:
<!-- pokemons_marker -->
* Terrakion (Drill Peck, Bubble Beam, Hydro Pump, Swagger)
* Deerling (Ice Beam, Rest, Confide)
* Sawsbuck (Ice Beam, Rest, Confide, Brutal Swing)
* Timburr (Rock Slide, Swagger)
* Gurdurr (Rock Slide, Swagger, Psycho Cut)
* Conkeldurr (Rock Slide, Swagger, Psycho Cut, Mud Shot)
<!-- pokemons_marker -->

## Исходный код программы
```
import java.lang.Math;

public class Main {

    public static void main(String[] args) {

        long[] c = new long[17];
        double[] x = new double[12];
        double[][] arr = new double[9][12];

        for (int i = 0, j = 5; i < c.length; j++, i++) {
            c[i] = j;
        }
        for (int i = 0; i < x.length; i++) {
            x[i] = -13.0 + (Math.random() * 13.0);
        }
        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr[0].length; j++) {
                if (c[i] == 21) {
                    arr[i][j] = Math.tan(Math.cbrt(Math.cos(x[j])));
                } else if (c[i] == 5 || c[i] == 7 || c[i] == 13 || c[i] == 15) {
                    arr[i][j] = Math.cos(Math.log10(Math.sin(x[j]) * Math.sin(x[j])));
                } else {
                    arr[i][j] = Math.pow(Math.PI / (Math.asin(Math.cos(Math.log10(Math.acos(x[j] / 26)))) + 1), 3);
                }

                System.out.printf("%-7.3f ", arr[i][j]);
            }
            System.out.println();
        }
    }
}

```
## Результат работы программы
```
0.992 0.523 0.999 1.000 0.280 0.780 0.997 0.985 0.993 0.697 0.762 0.906 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
0.992 0.523 0.999 1.000 0.280 0.780 0.997 0.985 0.993 0.697 0.762 0.906 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
2.674 2.597 2.549 2.367 2.405 2.427 2.448 2.383 2.348 2.496 2.427 2.587 
0.992 0.523 0.999 1.000 0.280 0.780 0.997 0.985 0.993 0.697 0.762 0.906 
```
> Следует учитывать, что каждый новый запуск программы будет давать новый уникальный вывод.

## Выводы по работе
???