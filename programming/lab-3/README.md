
# Лабораторная работа №5

_Мой вариант: `10013`_

## Запуск
Исполняемый файл доступен на Helios:

```bash
cd /home/s335050/lab-5
export EMODB=$your_path_to_json_file
java -jar lab-5.jar
```

## Защита

### 1. Коллекции. Сортировка элементов коллекции. Интерфейсы `java.util.Comparable` и `java.util.Comparator`.

#### Java Collection Framework.

Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK. Ниже представлена UML диаграма основных её элементов.

На верхушке располагаются интерфейсы `Collection` и `Map`. Они разделяют все коллекции на 2 части: простые последовательные наборы элементов (списки) и наборы пар «ключ - значение» (словари).

![](https://user-images.githubusercontent.com/76232618/172910557-7239db8d-10d3-4ec6-b7df-286d684aedeb.png)

При разработке бывает полезно использовать разные коллекции в зависимости от контекста и требований к производительности:

![image](https://user-images.githubusercontent.com/76232618/172916731-f4d4d9a1-168c-4051-9f48-9cd89beef7d9.png)

В коде лабораторной работы, в соотвествии с требованиями из текста задания моего варианта, для хранения родительских "дата-классов" используется `TreeMap`. Особенностью этой коллекции является автоматическая сортировка по значениям ключей.

#### Интерфейсы `Comparable` и `Comparator`.

Поддерживающие сортировку коллекции, при сортировке, пытаются привести хранящиеся в них объекты к типу `Comparable`. Поэтому для реализации сортировки по умолчанию объекты должны имплементировать интерфейс `Comparable`. 

Интерфейс `Comparable` типизируется текущим классом и содержит один единственный метод `compareTo`. `compareTo` принимает на вход объект указанного типа, сравнивает его с `this` и возвращает одно из трех чисел: `-1`, `0` или `1`, что соотвествует тому, что исходный объект меньше, равен или больше переданного объекта.

В коде лабораторной работы интерфейс `Comparable` имплементирует родительский "дата-класс" `HumanBeing`:
```java
    
public class HumanBeing implements Comparable<HumanBeing> {
    ...
    @Override
    public int compareTo(HumanBeing hb) {
        return -hb.getId().compareTo(getId());
    }
}
```

Сравнение объектов в данной реализации происходит на основе сравнения их `id`-полей. Это удобно при отладке и делает корректность сравнения очевидной при выводе объектов с помощью команды `print_descending`.

Однако при разработке может возникнуть потребность в реализации кастомного механизма сравнения, отличающегося от изначально заложенного разработчиком библиотеки при помощи интерфейса `Comparable`. Интерфейс `Comparator` решает эту проблему, предлагая создать собственный компоратор для сравнения объектов определенного типа. Ключевым методом в интерфейсе является метод `compare`. Он работает аналогичным методу `compareTo` из интерфейса `Comparable` образом, однако принимает на вход 2 объекта и сравнивает их между собой. Объект типа `Comparable` можно передать в конструктор поддерживающей сортировку коллекции для переопределения сортировки по умолчанию.

Также следует упомянуть то, что начиная с JDK 8 появилась возможно использования цепочек компораторов для реализации сравнения по приоритету. Для этого необходимо вызвать от старшего по приоритету корпоратора метод `thenComparing` и передать в него младший.

### 2. Категории коллекций - списки, множества. Интерфейс `java.util.Map` и его реализации.

Как уже было упомянуто выше, интерфейс `java.util.Map` описывает коллекцию, являющуюся словарем, т.е содержащей наборы пар "ключ - значение". Он описывает множество методов, наиболее используемыми, на мой взгляд, являются `put` (для добавления пары "ключ - значение"), `remove` (для удаления пары по ключу), `keySet` и `values` (для обработки элементов коллекции в цикле). Основными реализациями являются `Hashmap`, `LinkedHashMap`, `Hashtable`, `TreeMap`.

`Hashtable` - реализована раньше чем Java Collection Framework и является прообразом `HashMap`. Из-за того, что эта коллекция является синхронизированной, её использование в многопоточных архитектурах ограничено. Не позволяет использовать `null` в качестве значения или ключа. Не является упорядоченной (порядок хранения зависит от хэшей)

`HashMap` - является альтернативой `Hashtable`, но в отличии от неё не синхронизирована. Позволяет использовать `null` в качестве значения значения или ключа и аналогично `Hashtable` не является упорядоченной.

`LinkedHashMap` - упорядоченная реализация `Hashtable`. Пары хранятся в порядке добавления.

`TreeMap` - как и `LinkedHashMap` является упорядоченной, однако сортировка происходит на основе компораторов.

### 3. Параметризованные типы. Создание параметризуемых классов. Wildcard-параметры.

#### Параметризованные типы.

Параметризованные типы (или _дженерики_) позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Используя дженерики, можно создать единственный класс, например, который будет автоматически работать с разными типами данных. Фактически являются синтаксическим сахаром и во время компиляции преобразуются к кастам. 

Параметризуемые классы создаются следующим образом:

```java
public interface List<E> extends Collection<E> {
    ...
    boolean add(E e); // Метод использующий аргумент с параметризованными типом
    E get(int index); // Метод возвращающий объект параметризованного типа
}
```

#### Wildcard-параметры.

Из соображение типобезопасности, по умолчанию параметризованные типы инварианты. Однако в некоторых кейсах это существенно усложняет взаимодействие с ними. Для этого существуют _Wildcard-параметры_. Они задаются при помощи `? extends ...` или `? super ...`. `? extends ...` указывает верхнюю границу в цепочке наследования, `? super ...` - нижнюю. Следует отметить, что контейнер объявленный с `? extends ...` позволяет лишь читать значения (добавить можно только `null`). Обратная ситуация происходит с контейнером объявленным при помощи `? super ...`: возможно добавление любого значения, однако читать можно только объекты класса `Object`.

### 4. Классы-оболочки. Назначение, область применения, преимущества и недостатки. Автоупаковка и автораспаковка.
**Классы-оболочки** являются обертками над примитивными типами. Они расширяют их функционал, реализуют методы для парсинга, различных представлений примитивных типов (например hex) и получения вспомогательной информации. 

**Недостатком** является снижение производительности и большее количество занимаемой памяти. 

**Автоупаковка и автораспаковка** - инструменты позволяющие автоматически инкапсулировать примитивные типы в классы-оболочки и автоматически получать примитивные представления классов-оболочек.

```java
...
Integer a = 1337;
int b = a; // b = 1337
...
```

### 5. Потоки ввода-вывода в Java. Байтовые и символьные потоки. "Цепочки" потоков (Stream Chains).
### 6. Работа с файлами в Java. Класс `java.io.File`.
### 7. Пакет `java.nio` - назначение, основные классы и интерфейсы.
### 8. Утилита `javadoc`. Особенности автоматического документирования кода в Java.

Утилита `javadoc` предназначена для генерации документации в HTML-формате на основе комментариев размещенных в коде. `javadoc` также является стандартом документирования Java кода. Первоначально является консольной утилитой, однако большинство IDE позволяют сгенерировать HTML-документацию автоматически.

# Статьи

При подготовке мной были изучены следующие источники:

https://habr.com/ru/post/237043/
https://habr.com/ru/company/sberbank/blog/416413/
