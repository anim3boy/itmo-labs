
# Лабораторная работа №5

_Мой вариант: `10013`_

## Запуск
Исполняемый файл доступен на Helios:

```bash
cd /home/s335050/lab-5
export EMODB=$your_path_to_json_file
java -jar lab-5.jar
```

## Защита

### 1. Коллекции. Сортировка элементов коллекции. Интерфейсы `java.util.Comparable` и `java.util.Comparator`.

#### Java Collection Framework.

Java Collection Framework — иерархия интерфейсов и их реализаций, которая является частью JDK. Ниже представлена UML диаграма основных её элементов.

На верхушке располагаются интерфейсы `Collection` и `Map`. Они разделяют все коллекции на 2 части: простые последовательные наборы элементов (списки) и наборы пар «ключ - значение» (словари).

![](https://user-images.githubusercontent.com/76232618/172910557-7239db8d-10d3-4ec6-b7df-286d684aedeb.png)

`List` - наследует интерфейс `Collection` и представляет функционал для списков объектов. Предоставляется возможность доступа к элементам коллекции по индексу и по значению (так как реализации позволяют хранить дубликаты, результатом поиска по значению будет первое найденное вхождение).

`Queue` - наследует интерфейс `Collection` и представляет функционал для структур данных в виде очереди.

`Deque` - наследует интерфейс `Queue` и представляет функционал для двунаправленных очередей.

`Set` - также расширяет интерфейс `Collection` и используется для хранения множеств уникальных объектов.

`Map`: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет определенный ключ и значение. В отличие от других интерфейсов коллекций не наследуется от интерфейса `Collection`. Про `Map` будет рассказано подробнее в ответе на следующий вопрос.

Интерфейс `List` имплементируют следующие классы:

`Vector` - реализация динамического массива объектов. Позволяет хранить любые данные, включая null в качестве элемента. Не рекомендуется использовать, если этого не требует задача достижения потокобезопасности (все операции с данными являются синхронизированными).

`ArrayList` - не синхронизированная замена `Vector`. Позволяет выполнять обращение к элементам за константу.

`LinkedList` - особенностью реализации данной коллекции является то, что в её основе лежит двунаправленный связный список. Как эломент хранит ссылку на следующий и предыдущий.

Интерфейс `Set` имплементируют следующие классы:

`HashSet` - реализация `Set`, базирующаяся на `HashMap`. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (`new Object()`).

`LinkedHashSet` - реализация `Set` с `LinkedHashMap` в основе.

`TreeSet` - реализация `Set` с `NavigableMap` в основе. Позволяет управлять порядком с помощью `Comparator`.

При разработке бывает полезно использовать разные коллекции в зависимости от контекста и требований к производительности.

<!-- ![image](https://user-images.githubusercontent.com/76232618/172916731-f4d4d9a1-168c-4051-9f48-9cd89beef7d9.png) -->

В коде лабораторной работы, в соотвествии с требованиями из текста задания моего варианта, для хранения родительских "дата-классов" используется `TreeMap`. Особенностью этой коллекции является автоматическая сортировка по значениям ключей.

#### Интерфейсы `Comparable` и `Comparator`.

Поддерживающие сортировку коллекции, при сортировке, пытаются привести хранящиеся в них объекты к типу `Comparable`. Поэтому для реализации сортировки по умолчанию объекты должны имплементировать интерфейс `Comparable`. 

Интерфейс `Comparable` типизируется текущим классом и содержит один единственный метод `compareTo`. `compareTo` принимает на вход объект указанного типа, сравнивает его с `this` и возвращает одно из трех чисел: `-1`, `0` или `1`, что соотвествует тому, что исходный объект меньше, равен или больше переданного объекта.

В коде лабораторной работы интерфейс `Comparable` имплементирует родительский "дата-класс" `HumanBeing`:
```java
    
public class HumanBeing implements Comparable<HumanBeing> {
    ...
    @Override
    public int compareTo(HumanBeing hb) {
        return -hb.getId().compareTo(getId());
    }
}
```

Сравнение объектов в данной реализации происходит на основе сравнения их `id`-полей. Это удобно при отладке и делает корректность сравнения очевидной при выводе объектов с помощью команды `print_descending`.

Однако при разработке может возникнуть потребность в реализации кастомного механизма сравнения, отличающегося от изначально заложенного разработчиком библиотеки при помощи интерфейса `Comparable`. Интерфейс `Comparator` решает эту проблему, предлагая создать собственный компоратор для сравнения объектов определенного типа. Ключевым методом в интерфейсе является метод `compare`. Он работает аналогичным методу `compareTo` из интерфейса `Comparable` образом, однако принимает на вход 2 объекта и сравнивает их между собой. Объект типа `Comparable` можно передать в конструктор поддерживающей сортировку коллекции для переопределения сортировки по умолчанию.

Также следует упомянуть то, что начиная с JDK 8 появилась возможно использования цепочек компораторов для реализации сравнения по приоритету. Для этого необходимо вызвать от старшего по приоритету корпоратора метод `thenComparing` и передать в него младший.

### 2. Категории коллекций - списки, множества. Интерфейс `java.util.Map` и его реализации.

Как уже было упомянуто выше, интерфейс `java.util.Map` описывает коллекцию, являющуюся словарем, т.е содержащую наборы пар "ключ - значение". Он описывает множество методов, наиболее используемыми, на мой взгляд, являются `put` (для добавления пары "ключ - значение"), `remove` (для удаления пары по ключу), `keySet` и `values` (для обработки элементов коллекции в цикле). Основными реализациями являются `Hashmap`, `LinkedHashMap`, `Hashtable`, `TreeMap`.

`Hashtable` - реализована раньше чем Java Collection Framework и является прообразом `HashMap`. Из-за того, что эта коллекция является синхронизированной, её использование в многопоточных архитектурах ограничено. Не позволяет использовать `null` в качестве значения или ключа. Не является упорядоченной (порядок хранения зависит от хэшей). Благодаря использованию хэш-таблицы, реализует поиск за O(1) в случае отстуствия коллизий и за O(n) в худшем случае.

`HashMap` - является альтернативой `Hashtable`, но в отличии от неё не синхронизирована. Позволяет использовать `null` в качестве значения значения или ключа и аналогично `Hashtable` не является упорядоченной.

`LinkedHashMap` - упорядоченная реализация `HashMap`. Пары хранятся в порядке добавления.

`TreeMap` - как и `LinkedHashMap` является упорядоченной, однако сортировка происходит на основе компораторов. Реализует все операции за `O(log n)` (высота бинарного дерева).

### 3. Параметризованные типы. Создание параметризуемых классов. Wildcard-параметры.

#### Параметризованные типы.

Параметризованные типы (или _дженерики_) позволяют объявлять классы, интерфейсы и методы, где тип данных, которыми они оперируют, указан в виде параметра. Используя дженерики, можно создать единственный класс, например, который будет автоматически работать с разными типами данных. Фактически являются синтаксическим сахаром и во время компиляции преобразуются к кастам. 

Параметризуемые классы создаются следующим образом:

```java
public interface List<E> extends Collection<E> {
    ...
    boolean add(E e); // Метод использующий аргумент с параметризованными типом
    E get(int index); // Метод возвращающий объект параметризованного типа
}
```

#### Wildcard-параметры.

Из соображение типобезопасности, по умолчанию параметризованные типы инварианты. Однако в некоторых кейсах это существенно усложняет взаимодействие с ними. Для этого существуют _Wildcard-параметры_. Они задаются при помощи `? extends ...` или `? super ...`. `? extends ...` указывает верхнюю границу в цепочке наследования, `? super ...` - нижнюю. Следует отметить, что контейнер объявленный с `? extends ...` позволяет лишь читать значения (добавить можно только `null`). Обратная ситуация происходит с контейнером объявленным при помощи `? super ...`: возможно добавление любого значения, однако читать можно только объекты класса `Object`.

### 4. Классы-оболочки. Назначение, область применения, преимущества и недостатки. Автоупаковка и автораспаковка.
**Классы-оболочки** являются обертками над примитивными типами. Они расширяют их функционал, реализуют методы для парсинга, различных представлений примитивных типов (например hex) и получения вспомогательной информации. 

**Недостатком** является снижение производительности и большее количество занимаемой памяти. 

**Автоупаковка и автораспаковка** - инструменты позволяющие автоматически инкапсулировать примитивные типы в классы-оболочки и автоматически получать примитивные представления классов-оболочек.

```java
...
Integer a = 1337;
int b = a; // b = 1337
...
```

### 5. Потоки ввода-вывода в Java. Байтовые и символьные потоки. "Цепочки" потоков (Stream Chains).

В Java основной функционал работы с потоками сосредоточен в классах из пакета `java.io`. В пакете представлены 2 абстрактных класса для работы с потоками байтов: `InputStream` и `OutputStream` 

![image](https://user-images.githubusercontent.com/76232618/173061206-9b299b98-f766-481a-bebc-a111bad73ef4.png)

и 2 абстрактных класса для работы с потоками символов: `Reader` и `Writer` (Java использует юникод, где каждый символ кодируется двумя байтами).

![image](https://user-images.githubusercontent.com/76232618/173061227-f2601ccc-1d65-4a06-bbc3-d7e2e093e82b.png)

Как было сказано выше, в Java IO основной парадигмой является поток, а это значит, что возможно лишь чтение одного или нескольких байтов из потока за раз, пока все байты не будут прочитаны. 

Также в Java IO используется блокирующий (синхронный) ввод/вывод. Это означает, что при выполнения какой-либо операции из пакета `java.io` (например `read` или `write`) родительский поток (thread) будет заблокирован до тех пор, пока данные не будут считаны или записаны. Это позволяет не выполнять лишних проверок при работе с потоками, однако влияет на производительность.

#### Stream Chains.

Поток может читать данные не только из источника данных, который их хранит, но из другого потока. Это позволяет комбинировать потоки обладающие различными свойствами для решения сложных задач. Так, например, можно реализовать чтение с консоли оперируя символами и строками:

```java
InputStream stream = System.in;
InputStreamReader reader = new InputStreamReader(stream);
BufferedReader buff = new BufferedReader(reader);
String line = buff.readLine();
```

### 6. Работа с файлами в Java. Класс `java.io.File`.

Работу с файлами в Java IO осуществляет класс `java.io.File`. Он не работает с потоками напрямую, и его основной задачей является хранение информации о файлах и каталогах. В операционной системе каталоги и файлы являются разными объектами, однако в Java IO могут быть представлены `java.io.File`. Проверить чем является объект класса `File` можно при помощи методов `isFile` и `isDirectory`. На мой взгляд, в Java NIO реализована более удобная работа с файловой системой.

### 7. Пакет `java.nio` - назначение, основные классы и интерфейсы.

Java NIO (Java New IO) используется буфер-ориентированный подход и доступно большое количество методов для взаимодействия с буфером. Несмотря на то, что в купе с неблокирующим (асинхронным) вводом/выводом это обеспечивает лучшую производительность, в сравнении с Java IO, накладывает на программиста ряд задач, связанных с обработкой буфера. Например, единственны вариант понять, достаточно ли данных для корректной обработки буфера в зависимости от контекста - посмотреть его содержимое. `java.nio.file` реализует более комплексное взаимодействие с файловой системой. Наличие селекторов продолжают идею асинхронности `java.nio` добавляя возможность обработки одним селекторов нескольких каналов.

Изучив [документацию](https://docs.oracle.com/javase/10/docs/api/java/nio/package-summary.html), можно сделать вывод что пакет `java.nio` состоит из следующих элементов:

`Buffers` - промежуточные контейнеры для информации. Например абстрактный класс `Buffer` или `ByteBuffer`.

`Charsets` - пакет `java.nio.charset`, содержащий абстрактные классы `Charset`, `CharsetEncoder` и `CharsetDecoder`. Правила конвертации бинарных символов в Java UTF-16 и обратно. 

`Channels` - пакет `java.nio.channels`, реализации интерфейса `Channel` – сущности, представляющие соединения между разными участниками ввода-вывода (файлы, сокеты, консоль).

`Selectors` - пакет `java.nio.channels`, наследники класса `Selector`. Комбинируют несколько каналов в один. Регистрация канала в селекторе возвращает `SelectionKey`, который содержит ссылку на сам канал, и ряд его атрибутов. Селектор позволяет выбрать из набора зарегистрированных каналов подмножество готовых к работе, при необходимости блокируя выполнение на время ожидания. 

### 8. Утилита `javadoc`. Особенности автоматического документирования кода в Java.

Утилита `javadoc` предназначена для генерации документации в HTML-формате на основе комментариев размещенных в коде. `javadoc` также является стандартом документирования Java кода. Первоначально является консольной утилитой, однако большинство IDE позволяют сгенерировать HTML-документацию автоматически.

При помощи технологии `javadoc` реализована документация на сайте Oracle: https://docs.oracle.com/javase/8/docs/api/

# Статьи

При подготовке мной были изучены следующие источники:

https://habr.com/ru/post/237043/

https://habr.com/ru/company/sberbank/blog/416413/

https://habr.com/ru/post/235585/

https://metanit.com/java/tutorial/6.11.php

https://docs.oracle.com/javase/10/docs/api/java/nio/package-summary.html
