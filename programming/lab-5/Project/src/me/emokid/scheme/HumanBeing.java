package me.emokid.scheme;

import me.emokid.IO.UserInputReader;
import me.emokid.command.ExceptionMessage;
import me.emokid.scheme.exception.IllegalBoundsException;
import me.emokid.json.JSONMap;
import me.emokid.utils.MessageType;
import me.emokid.utils.Utils;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.time.LocalDateTime;
import java.util.Map;
import java.util.Objects;

public class HumanBeing implements Comparable<HumanBeing> {

    /**
     * Constant used in {@link #setImpactSpeed(Float)}
     */

    private static final Float MAX_IMPACT_SPEED_VALUE = 376f;

    /**
     * Identifies the {@link #HumanBeing}
     * It is unique positive autogenerated value
     */

    private Integer id;

    /**
     * {@link #HumanBeing}'s name.
     * Not empty and not {@code null}
     */

    private String name;

    /**
     * {@link #HumanBeing}'s coordinates
     * Not {@code null}
     */

    private Coordinates coordinates;

    /**
     * {@link #HumanBeing}'s object creation date
     * Not {@code null}, autogenerated
     */

    private java.time.LocalDateTime creationDate;

    /**
     * {@link #HumanBeing}'s hero status
     */

    private boolean realHero;

    /**
     * {@link #HumanBeing}'s having a toothpick
     * Not {@code null}
     */

    private Boolean hasToothpick;

    /**
     * {@link #HumanBeing}'s impact speed
     * Not {@code null}
     */

    private float impactSpeed;

    /**
     * {@link #HumanBeing}'s soundtrack name
     * Max value is 376
     */

    private String soundtrackName;

    /**
     * {@link #HumanBeing}'s minutes of waiting
     * Not {@code null}
     */

    private float minutesOfWaiting;

    /**
     * {@link #HumanBeing}'s mood
     */

    private Mood mood;

    /**
     * {@link #HumanBeing}'s car
     * Not {@code null}
     */

    private Car car;

    /**
     * {@link #HumanBeing}'s id are setting from parent object, creationDate are creating by default
     * other fields are filling by user line by line input
     *
     * @param id              id to set (format: {@link #id})
     * @param userInputReader is needs for user input reading
     * @throws NullPointerException
     * @throws IllegalBoundsException
     */

    public HumanBeing(int id, UserInputReader userInputReader) throws NullPointerException, IllegalBoundsException {
        setId(id);
        setCreationDate();
        setValuesByUserInput(userInputReader);
    }

    /**
     * Fill all {@link #HumanBeing}'s fields by JSONMap
     *
     * @param jsonMap is using to fill all fields
     * @throws NullPointerException   if some field can't be {@code null}, but {@code null} is given
     * @throws IllegalBoundsException if some field is getting out of bounds value
     * @throws NumberFormatException  if not possible to parse number from JSON map
     */

    public HumanBeing(JSONMap jsonMap) throws NullPointerException, IllegalBoundsException, NumberFormatException {
        setValuesByJSONMap(jsonMap);
    }

    /**
     * Fills all {@link #HumanBeing}'s fields by JSONMap
     *
     * @param jsonMap is using to fill all fields
     * @throws NullPointerException   if some field can't be {@code null}, but {@code null} is given
     * @throws IllegalBoundsException if some field is getting out of bounds value
     * @throws NumberFormatException  if not possible to parse number from JSON map
     */

    private void setValuesByJSONMap(JSONMap jsonMap) throws NullPointerException, IllegalBoundsException, NumberFormatException {

        Map<String, Object> unpackedjsonMap = jsonMap.getData();

        for (Field field : getClass().getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())) {
                continue;
            }

            String fieldName = field.getName();
            String JSONFieldValue;
            if (unpackedjsonMap.get(fieldName) == null) {
                JSONFieldValue = null;
            }
            else {
                JSONFieldValue = unpackedjsonMap.get(fieldName).toString();
            }

            switch (fieldName) {
                case "id":
                    setId(jsonMap.getNumber(fieldName).toInt());
                    break;
                case "creationDate":
                    setCreationDate(LocalDateTime.parse(JSONFieldValue));
                    break;
                case "name":
                    setName(JSONFieldValue);
                    break;
                case "realHero":
                    setRealHero(Utils.parseBoolean(JSONFieldValue));
                    break;
                case "hasToothpick":
                    setHasToothpick(Utils.parseBoolean(JSONFieldValue));
                    break;
                case "impactSpeed":
                    setImpactSpeed(jsonMap.getNumber(fieldName).toFloat());
                    break;
                case "soundtrackName":
                    setSoundtrackName(JSONFieldValue);
                    break;
                case "minutesOfWaiting":
                    setMinutesOfWaiting(jsonMap.getNumber(fieldName).toFloat());
                    break;
                case "mood":
                    setMood(Utils.parseEnum(JSONFieldValue));
                    break;
                case "coordinates":
                    setCoordinates(new Coordinates(jsonMap.getJSONMap(fieldName)));
                    break;
                case "car":
                    setCar(new Car(jsonMap.getJSONMap(fieldName)));
                    break;
            }
        }
    }

    /**
     * Fills some {@link #HumanBeing}'s fields from line by line user input
     *
     * @param userInputReader is needs for user input reading
     */

    private void setValuesByUserInput(UserInputReader userInputReader) {
        Package currentPackage = getClass().getPackage();

        for (Field field : getClass().getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())){
                continue;
            }

            String fieldName = field.getName();
            if (fieldName.equals("id") || fieldName.equals("creationDate")){
                continue;
            }

            Package fieldPackage = field.getType().getPackage();

            while (true) {
                if (currentPackage == fieldPackage && !field.getType().isEnum()) {
                    switch (fieldName) {
                        case "coordinates":
                            Utils.print(MessageType.PART_OF_LIST, fieldName + ":");
                            setCoordinates(new Coordinates(userInputReader));
                            break;
                        case "car":
                            Utils.print(MessageType.PART_OF_LIST, fieldName + ":");
                            setCar(new Car(userInputReader));
                            break;
                    }
                    break;
                }
                try {
                    int defaultDepth = 0;
                    String userInput = userInputReader.inputField(defaultDepth, field);
                    switch (fieldName) {
                        case "name":
                            setName(userInput);
                            break;
                        case "realHero":
                            setRealHero(Utils.parseBoolean(userInput));
                            break;
                        case "hasToothpick":
                            setHasToothpick(Utils.parseBoolean(userInput));
                            break;
                        case "impactSpeed":
                            setImpactSpeed(Utils.parseFloat(userInput));
                            break;
                        case "soundtrackName":
                            setSoundtrackName(userInput);
                            break;
                        case "minutesOfWaiting":
                            setMinutesOfWaiting(Utils.parseFloat(userInput));
                            break;
                        case "mood":
                            setMood(Utils.parseEnum(userInput));
                            break;
                    }
                    break;
                } catch (NullPointerException e) {
                    Utils.print(MessageType.ERROR, ExceptionMessage.COULD_BE_NULL);
                } catch (NumberFormatException e) {
                    Utils.print(MessageType.ERROR, ExceptionMessage.CANT_PARSE);
                } catch (Exception e) {
                    Utils.print(MessageType.ERROR, e.getMessage());
                }
            }
        }
    }

    /**
     * Nice printing for all {@link #HumanBeing}'s fields
     */

    public void print() {
        Package currentPackage = getClass().getPackage();

        for (Field field : getClass().getDeclaredFields()) {
            if (Modifier.isStatic(field.getModifiers())) {
                continue;
            }

            String fieldName = field.getName();

            Package fieldPackage = field.getType().getPackage();

            if (currentPackage == fieldPackage && !field.getType().isEnum()) {
                switch (fieldName) {
                    case "coordinates":
                        Utils.print(MessageType.PART_OF_LIST, fieldName + ":");
                        getCoordinates().print();
                        break;
                    case "car":
                        Utils.print(MessageType.PART_OF_LIST, fieldName + ":");
                        getCar().print();
                        break;
                }
            }

            int defaultDepth = 0;
            switch (fieldName) {
                case "id":
                    Utils.printField(defaultDepth, field, String.valueOf(getId()));
                    break;
                case "creationDate":
                    Utils.printField(defaultDepth, field, getReadableCreationDate());
                    break;
                case "name":
                    Utils.printField(defaultDepth, field, getName());
                    break;
                case "realHero":
                    Utils.printField(defaultDepth, field, String.valueOf(isRealHero()));
                    break;
                case "hasToothpick":
                    Utils.printField(defaultDepth, field, String.valueOf(getHasToothpick()));
                    break;
                case "impactSpeed":
                    Utils.printField(defaultDepth, field, String.valueOf(getImpactSpeed()));
                    break;
                case "soundtrackName":
                    Utils.printField(defaultDepth, field, getSoundtrackName());
                    break;
                case "minutesOfWaiting":
                    Utils.printField(defaultDepth, field, String.valueOf(getMinutesOfWaiting()));
                    break;
                case "mood":
                    Utils.printField(defaultDepth, field, String.valueOf(getMood()));
                    break;
            }
        }
    }

    /**
     * @return id
     */

    public Integer getId() {
        return id;
    }

    /**
     * Check {@link #id} value on {@code null} and bounds and sets
     *
     * @param id id to set
     * @throws NullPointerException   if id object is empty (equals to {@code null})
     * @throws IllegalBoundsException if id is negative
     */

    public void setId(Integer id) throws NullPointerException, IllegalBoundsException {
        if (id == null) {
            throw new NullPointerException();
        }
        if (id <= 0) {
            throw new IllegalBoundsException(ExceptionMessage.CANT_BE_NEGATIVE);
        }
        this.id = id;
    }

    /**
     * @return name
     */

    public String getName() {
        return name;
    }

    /**
     * Check {@link #name} value on {@code null} and emptiness and sets
     *
     * @param name name to set
     * @throws NullPointerException   if name is {@code null}
     * @throws IllegalBoundsException if name is empty
     */

    public void setName(String name) throws NullPointerException, IllegalArgumentException {
        if (name == null) {
            throw new NullPointerException();
        }
        if (name.isEmpty()) {
            throw new IllegalBoundsException(ExceptionMessage.CANT_BE_EMPTY);
        }
        this.name = name;
    }

    /**
     * @return coordinates
     */

    public Coordinates getCoordinates() {
        return coordinates;
    }

    /**
     * Check {@link #coordinates} value on {@code null} and sets
     *
     * @param coordinates coordinates to set
     * @throws NullPointerException if coordinates is {@code null}
     */

    public void setCoordinates(Coordinates coordinates) throws NullPointerException {
        if (coordinates == null) {
            throw new NullPointerException();
        }
        this.coordinates = coordinates;
    }

    /**
     * @return nice formatted creationDate field
     */

    public String getReadableCreationDate() {
        return getCreationDate().format(Utils.getDateFormatter());
    }

    /**
     * @return creationDate
     */

    public LocalDateTime getCreationDate() {
        return creationDate;
    }

    /**
     * Sets {@link #creationDate} by current datetime
     */

    public void setCreationDate() {
        this.creationDate = LocalDateTime.now();
    }

    /**
     * Check {@link #creationDate} value on {@code null} and sets
     *
     * @param creationDate creationDate to set
     * @throws NullPointerException if creationDate is {@code null}
     */

    public void setCreationDate(LocalDateTime creationDate) {
        if (creationDate == null) {
            throw new NullPointerException();
        }
        this.creationDate = creationDate;
    }

    /**
     * @return isRealHero
     */

    public boolean isRealHero() {
        return realHero;
    }

    /**
     * Check {@link #realHero} value on {@code null} and sets
     *
     * @param realHero realHero to set
     * @throws NullPointerException if realHero is {@code null}
     */

    public void setRealHero(Boolean realHero) throws NullPointerException {
        if (realHero == null) {
            throw new NullPointerException();
        }
        this.realHero = realHero;
    }

    /**
     * @return hasToothpick
     */

    public Boolean getHasToothpick() {
        return hasToothpick;
    }

    /**
     * Check {@link #hasToothpick} value on {@code null} and sets
     *
     * @param hasToothpick hasToothpick to set
     * @throws NullPointerException if hasToothpick is {@code null}
     */

    public void setHasToothpick(Boolean hasToothpick) throws NullPointerException {
        if (hasToothpick == null) {
            throw new NullPointerException();
        }
        this.hasToothpick = hasToothpick;
    }

    /**
     * @return impactSpeed
     */

    public float getImpactSpeed() {
        return impactSpeed;
    }

    /**
     * Check {@link #impactSpeed} value on {@code null} and bounds and sets
     *
     * @param impactSpeed impactSpeed to set
     * @throws NullPointerException   if impactSpeed object is empty (equals to {@code null})
     * @throws IllegalBoundsException if impactSpeed is greater than {@link #MAX_IMPACT_SPEED_VALUE}
     */

    public void setImpactSpeed(Float impactSpeed) throws NullPointerException, IllegalArgumentException {
        if (impactSpeed == null) {
            throw new NullPointerException();
        }
        if (impactSpeed > MAX_IMPACT_SPEED_VALUE){
            throw new IllegalBoundsException(String.format(ExceptionMessage.MAX_VALUE_IS_FORMAT, MAX_IMPACT_SPEED_VALUE));
        }
        this.impactSpeed = impactSpeed;
    }

    /**
     * @return soundtrackName
     */

    public String getSoundtrackName() {
        return soundtrackName;
    }

    /**
     * Check {@link #soundtrackName} value on {@code null} and sets
     *
     * @param soundtrackName soundtrackName to set
     * @throws NullPointerException if soundtrackName object is empty (equals to {@code null})
     */

    public void setSoundtrackName(String soundtrackName) throws NullPointerException {
        if (soundtrackName == null) {
            throw new NullPointerException();
        }
        this.soundtrackName = soundtrackName;
    }

    /**
     * @return minutesOfWaiting
     */

    public float getMinutesOfWaiting() {
        return minutesOfWaiting;
    }

    /**
     * Check {@link #minutesOfWaiting} value on {@code null} and sets
     *
     * @param minutesOfWaiting minutesOfWaiting to set
     * @throws NullPointerException if minutesOfWaiting object is empty (equals to {@code null})
     */

    public void setMinutesOfWaiting(Float minutesOfWaiting) throws NullPointerException {
        if (minutesOfWaiting == null) {
            throw new NullPointerException();
        }
        this.minutesOfWaiting = minutesOfWaiting;
    }

    /**
     * @return mood
     */

    public Mood getMood() {
        return mood;
    }

    /**
     * Set mood value
     *
     * @param mood mood to set
     */

    public void setMood(Mood mood) {
        this.mood = mood;
    }

    /**
     * @return car
     */

    public Car getCar() {
        return car;
    }

    /**
     * Check {@link #car} value on {@code null} and sets
     *
     * @param car car to set
     * @throws NullPointerException if car object is empty (equals to {@code null})
     */

    public void setCar(Car car) throws NullPointerException {
        if (car == null) {
            throw new NullPointerException();
        }
        this.car = car;
    }

    @Override
    public String toString() {
        return "(" +
                "id=" + id +
                ", name=" + name +
                ", ...)";
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        HumanBeing humanBeing = (HumanBeing) obj;
        return Objects.equals(humanBeing.name, this.name) &&
                Objects.equals(humanBeing.coordinates, this.coordinates) &&
                Objects.equals(humanBeing.creationDate, this.creationDate) &&
                humanBeing.isRealHero() == this.isRealHero() &&
                humanBeing.getHasToothpick() == this.getHasToothpick() &&
                Objects.equals(humanBeing.impactSpeed, this.impactSpeed) &&
                Objects.equals(humanBeing.soundtrackName, this.soundtrackName) &&
                Objects.equals(humanBeing.minutesOfWaiting, this.minutesOfWaiting) &&
                Objects.equals(humanBeing.getMood(), this.getMood()) &&
                Objects.equals(humanBeing.getCar(), this.getCar());
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name, coordinates, creationDate, realHero, hasToothpick, impactSpeed, soundtrackName, minutesOfWaiting, mood, car);
    }

    @Override
    public int compareTo(HumanBeing hb) {
        return -hb.getId().compareTo(getId());
    }

}

